const {Wit, log} = require('node-wit');

const logLevels = ["debug", "info", "warn", "error"];

module.exports = function (options) {

    function logConsole(logLevel,msg){
        if (logLevels.indexOf(logLevel.toLowerCase()) >= logLevels.indexOf(options.logLevel.toLowerCase())){
            console.log(msg);
        }
    }

    if (!options || !options.tokens || !options.tokens.default) {
        throw new Error('You should at least define a default token (ex: {default:\'[token]\'}');
    }

    function findClientByToken(accessToken){
        for (var locale_key in options.tokens) {
            if (options.tokens.hasOwnProperty(locale_key)) {
                if (clients[locale_key] && clients[locale_key].config.accessToken == accessToken) {
                    return clients[locale_key];
                }
            }
            return null;
        }
    }

    options.minConfidence = options.minConfidence || 0.5;
    options.logLevel = options.logLevel ? (logLevels.indexOf(options.logLevel) != -1 ? options.logLevel.toUpperCase() : "DEBUG") : null;

    // Instantiate Wit.ai clients
    var clients = {};
    Object.keys(options.tokens).forEach(function(key) {

        /* Checks is a client already exists for that token and assigns it to this key instead of
         * recreating a new client. Useful for languages shared in several locales (e.g: fr_FR and fr_CA)
         */
        clients[key] =  findClientByToken(options.tokens[key]);

        if (!clients[key]) {
            logConsole('debug','creating new client for '+ key)
            var params = {accessToken: options.tokens[key]}
            if (options.logLevel) params.logger = new log.Logger(options.logLevel);
            clients[key] = new Wit({accessToken: options.tokens[key]})
        }
    });

    const middleware = {};

    middleware.receive = function (bot, message, next) {


        //Avoid text payload generated by buttons in Facebook Messenger
        if (message.text && message.text.indexOf("_") == -1 && !message.payload && !message.attachments && !message.quick_reply) {
            var client = clients[message.user_profile.locale] ? clients[message.user_profile.locale] : clients.default;
            client.message(message.text)
                .then((data) => {
                    logConsole('debug','Wit.ai response: ' + JSON.stringify(data));
                    message.entities = data.entities;
                    next();
                })
                .catch((err) => {
                    logConsole('error', err);
                    next(err);
                });
        } else {
            message.entities = {};
            next();
        }
    };

    middleware.hears = function (patterns, message) {
        if (patterns && message && message.entities && Object.keys(message.entities).length) {
            for (var i = 0; i < Object.keys(message.entities).length; i++) {
                for (var t = 0; t < patterns.length; t++) {
                    if (Object.keys(message.entities)[i] == patterns[t]){
                        for (var j = 0; j < message.entities[Object.keys(message.entities)[i]].length; j++){
                            if (message.entities[Object.keys(message.entities)[i]][j].confidence >= options.minConfidence){
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    };

    return middleware;
};
